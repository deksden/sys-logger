# v0.8.5-log Важные требования RULEZZ (`docs/RULEZZ.md`):


## 1) Стиль общения с пользователем в чате:

* основное описание системы в документе `DOC_SYS_LOGGER.md` SYS_LOGGER.md
* при общении используй для оформления markdown и emoji, если это поможет
* не знаешь чего-то, информация не ясна, или не уверен в чем то - так и говори, донеси ситуацию до пользователя
* список всех файлов и папок проекта в файле `all-files-and-directories.txt`


## 2) Файлы и папки:

* ВАЖНО(!!!): если требуется работать с файлом, а ты не видишь полного текста файла, скажи об этом пользователю и никогда НЕ РАБОТАЙ с файлом без полного текста;
* если тебе понадобился какой то файл, сообщай об этом пользователю, не пытайся строить предположения о содержимом файла;
* имена файлов в нижнем регистре с разделением слов дефисом
* код системы в папке "src/" внутри корневой папки проекта
* вложенные в "src/" папки формируют логические группировки файлов кода - подсистемы; они могут быть иерархическими (вложенными)
* система разделена на домены "исходный код" (src/), документация (doc/), тесты (test/)


## 3) Организация кода:

* предпочитай использовать функции, классы используются только в крайнем случае
* добавляй в код новые сущности (функции, классы, методы и константы) или удаляй сущности только если это согласовано в плане действий
* используй функциональный стиль организации кода
* придерживайся минималистического подхода, достигай поставленных задач, не усложняй код без явной необходимости, вноси новые сущности только по необходимости и обоснованно
* код должен быть максимально простым, понятным и читаемым
* используй лучшие практики: DRY, SRP, SOLID, YAGNI, избегай преждевременной оптимизации, продумывай цепочки вызовов и делай их согласованными
* предлагай оптимизации, когда их видишь
* не вноси изменений в код без основания, сохраняй код как он был, если нет ясной причины его менять
* делай только те функции и методы, которые непосредственно нужны для решения поставленной задачи; не создавай избыточных api "на всякий случай"
* стремись к чистым функциям, явным входным параметрам, предсказуемым результатам, минимальным побочным эффектам
* используй когда нужно композицию функций, переиспользование кода, маленькие специализированные функции если в нескольких местах нужен этот код
* неизменяемость: входные данные не модифицируются, если нужно менять входные данные используй новые объекты; делай четкие границы изменений
* делай функции дружественными к тестированию: изолированные функции, Внедрение зависимостей, мок только необходимого
* проверяй параметры функций, контролируй наличе всех важных параметров, обрабатывай и устанавливай значения по-умолчанию при необходимости;
* мы не используем "export default" (NO_EXPORT_DEFAULT) без специального указания или ясной причины; каждая функция экспортируется при объявлении, отдельно экспорты не декларируем
* используем Standard code style; стараемся не допускать предупреждений ESLint
* НИКОГДА не генерируй код частично с примечаниями вида "Остальной код остаётся неизменным" или "Остальные тесты остаются неизменными"


## 4) Обработка ошибок - паттерн SYS-ERRORS, ошибки операции:

* используем систему работы с ошибками SYS_ERRORS (документирована в `DOC_SYS_ERRORS.md`)
* для каждой функции нужно создать специфический код ошибки в errors-xxx подсистемы (ошкибку операции), и функцию фабрику для создания такой ошибки в файле error-fabs-xxx подсистемы, аргументы фабрики создадут SystemError с правильным контекстом;
* функция оборачивает все ошибки, произошедшие в ней, в свою специфическую ошибку (ошибку операции); исходная оригинальная ошибка доступна в .origin, и указывается как параметр originalError фабрики; подробнее написано в DOC_SYS_ERRORS;
* все ошибки, выбрасываемые нашим кодом, являются классом SystemError и должны создаваться своей фабрикой функцией;
* если ошибка произошла во внешней функции, нужно перехватить ошибку и обернуть ее в специфическую ошибку этой функции (указать в originalError при вызове фабрики функции);
* если мы сами выбрасываем ошибку внутри функции, мы также оборачиваем ее в специфическую ошибку функции (ошибку операции);
* в jsDoc мы указываем основную специфическую ошибку, которую выбрасывает функция, указываем ее фабрику-функцию, а также перечисляем ошибки, которые могут встретится в поле .original специфической ошибки;
* при определении кодов ошибок в errors-xxx подсистемы мы в jsDoc для кода ошибки, если это специфическая ошибка операции, указываем файл и функцию, для которой эта ошибка определена; аналогично документируем фабрику-функцию, которая выбрасывает специфическую ошибку операции - указываем в jsDoc файл и функцию, для которой создана эта фабрика, а также код создаваемой ошибки;. 


## 5) Dependency Injection:

* использование паттерна документировано в файле `DOC_DI.md`
* в коде для которого делаем модульные тесты используем механизм dependency injection
* в модуле объявляем экспортируемую константу dependencies и храним там все зависимости модуля
* все функции модуля используют зависимости из dependencies
* делаем экспортируемую функцию setDependencies для замены зависимостей в dependencies, например, на моки и стабы;
* при необходимости сохранить оригинальные зависимости, сохраняем значения из dependencies


## 6) Логирование:

* используем логгер SYS_LOGGER, подсистема логирования описана в `DOC_SYS_LOGGER.md`
* используй возможности логгера для выдачи полезной отладочной информации от уровня trace
* на уровне trace сообщай о старте функции и параметрах, о результате функции и значении
* сообщай о все существенных событиях в коде на уровне debug
* значимые события в логике приложения сообщая как info
* при ошибке делай подробный вывод error
* используй иные уровни при необходимости


## 7) Комментарии и jsDoc:

* в начале каждого файла кода ставим jsDoc с полным путём к файлу (относительно корневой папки проекта), описанием файла и версией файла
* комментарии и jsDoc на русском языке
* в тексте файла кода документируем jsDoc каждый важный элемент: переменная/константу, класс, функцию или метод с аргументами, возвращаемыми значениями, выбрасываемыми исключениями, и так далее
* когда документируем функцию, документируем не только экспортируемые, но и внутренние и вложенные функции
* при документировании функции:
  * в описании обязательно ясно и подробно указывай ожидаемое поведение функции, ее зоны ответственности, важные особенности реализации
  * документируй все аргументы с типами,
  * для аргументов со значениями по-умолчанию: укажи их в документации со значениями по-умолчанию,
  * укажи тип и описание возвращаемого значения
  * сделай перечень всех типов исключений, выбрасываемых функцией, включая те, которые конструируются фабриками ошибок error-fabs
  * раздел "детерминированность": оцени и укаже - если функция детерминирована, то напиши об этом, чтобы не мокать эту функцию без особой необходимости 
* все используемые типы данных документируются через typedef, включая структуру возвращаемых и получаемых как аргументы объектов
* если используем объекты с типами из внешних зависимостей, то пользуемся тэгом @import для импорта в jsDoc нужного нам типа (можно использовать импорт с именованием "import * as" при необходимости)

### 8) Версии:

* используем semantic versioning
* правила про версии касаются кода, тестов, документации (где есть версия)
* при фиксе багов увеличиваем patch версию;
* при добавлении или изменении функциональности увеличиваем minor версию
* при breaking изменении api увеличиваем major
* файлы кода, тестов, документации каждый имеют свою независимую нумерацию версий, не связанные друг с другом или с чем либо еще
* версия выше 9 будет 10 в том же разряде версии, а не увеличивает другой разряд;
* новые файлы начинаем с версии 0.1.0
* ВАЖНО! единственных синхронизированный по версиям документ - это DOC_SYS_LOGGER.md и package.json, там везде одинаковые версии с файлом logger.js, так как это версия библиотеки в целом (и это файлы для внешних пользователей). то есть мы меняем версии в этих файлах синхронно. 

### 9) Тесты:

* требования к тестам указаны в документе `UNI_TESTZ.md`: изучи этот документ внимательно для тестирования: 
  * как именовать тесты, 
  * целевые размеры файлов, 
  * организация тестов, как их делать, 
  * имена файлов, версии, 
  * логгер и моки
* папка для тестов - "test/"

## 10) Документация:

* папка для документации - "docs/" в корневой папке проекта
* документацию делаем в формате markdown;
* в конце заголовка каждого файла документации указываем в круглых скобках путь и полное имя файла (относительно корневой папки)
* пишем кратко, но приводим все существенные детали
* приводим примеры для необходимых пояснений
